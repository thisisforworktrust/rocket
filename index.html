<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Velocity Void — Stacked Upgrades</title>
<style>
  html,body{height:100%;margin:0;background:#030417;color:#dfefff;font-family:monospace;overflow:hidden}
  canvas{display:block}
  #ui{position:absolute;left:12px;top:12px;font-size:15px;z-index:5}
  #ui div{margin-bottom:6px}
  #overlay{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,0.6);color:#fff;z-index:10;backdrop-filter:blur(2px);
    visibility:hidden;opacity:0;transition:opacity .15s;
  }
  #panel{background:#071124;padding:18px;border-radius:10px;border:2px solid rgba(126,211,255,0.12);width:520px;text-align:center}
  #panel h2{margin:0 0 12px;font-size:22px}
  .choices{display:flex;gap:12px;justify-content:center}
  .choice{flex:1;padding:12px;border-radius:8px;background:#081827;cursor:pointer;border:2px solid rgba(255,255,255,0.04)}
  .choice:hover{border-color:#7dd3fc}
  .choice h3{margin:0 0 6px;font-size:16px}
  .small{font-size:13px;color:#9fb7c8}
  #overlay.show{visibility:visible;opacity:1}
  #msg{position:fixed;right:12px;top:12px;color:#cfefff;font-size:13px}
  #gameOver{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#fff;font-size:28px;z-index:12;display:none}
  button { cursor:pointer; }
  .upgradesSummary { margin-top:8px; font-size:12px; color:#9fb7c8; }
</style>
</head>
<body>
<div id="ui">
  <div id="ammoUi">Ammo: 10/10</div>
  <div id="killsUi">Kills: 0</div>
  <div id="boostUi">Boost: READY</div>
  <div id="metaUi">Max Missiles: 3 | Missile Speed Bonus: 0.00</div>
  <div class="upgradesSummary" id="upgradesUi">Upgrades: —</div>
</div>

<div id="overlay"><div id="panel">
  <h2>LEVEL UP!</h2>
  <div class="small">Pick one upgrade:</div>
  <div class="choices" id="choices"></div>
  <div style="margin-top:12px;color:#9fb7c8;font-size:13px">Game is paused during selection</div>
</div></div>

<div id="msg">Hold ⇧ to charge boost — Release to burst. Use Arrow keys to steer, Space to shoot. R to restart.</div>
<div id="gameOver">YOU DIED — Press R to restart</div>
<canvas id="c"></canvas>

<script>
/* -------------------------
   Configuration / Globals
   ------------------------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function fit(){ canvas.width = innerWidth; canvas.height = innerHeight; }
fit(); window.addEventListener('resize', ()=>{ fit(); makeStars(); });

const overlay = document.getElementById('overlay');
const choicesEl = document.getElementById('choices');
const ammoUi = document.getElementById('ammoUi');
const killsUi = document.getElementById('killsUi');
const boostUi = document.getElementById('boostUi');
const metaUi = document.getElementById('metaUi');
const upgradesUi = document.getElementById('upgradesUi');
const gameOverEl = document.getElementById('gameOver');

let keys = {};
addEventListener('keydown', e=>{ keys[e.code] = true; });
addEventListener('keyup', e=>{ keys[e.code] = false; });

let gameOver = false;
let pausedForUpgrade = false;

let killCount = 0;
let killsSinceLevel = 0;
let level = 1;

/* player */
const PLAYER_MAX_SPEED = 5;
let rocket = {
  x: canvas.width/2, y: canvas.height/2,
  vx: 0, vy: 0, angle: 0,
  thrustBase: 0.26, rotationSpeed: 0.07, drag: 0.99,
  thrustApplied: 0, thrustRampTime: 0.18
};

/* magazine & reload */
const BASE_MAX_AMMO = 12;
let maxAmmo = BASE_MAX_AMMO;
let magSize = 10;
let bulletsInMag = magSize;
const BASE_RELOAD = 1500;
let reloadTime = BASE_RELOAD;
let reloading = false;
const BASE_FIRE_RATE = 150;
let fireRate = BASE_FIRE_RATE;
let lastShotTime = 0;

/* boost */
let boosting = false;
let boostCharge = 0;
const BOOST_CHARGE_TIME = 900;
let boostReady = true;
const BOOST_COOLDOWN = 4000;
let lastBoostAt = -9999;

/* bullets & missiles */
let bullets = [];
let missiles = [];

/* missile cap & scaling */
let startingMissileCap = 3;
let missileCap = startingMissileCap;
const missileCapMax = 15;
let baseDifficultySpeedBonus = 0;

/* upgrade state (counters) */
let upgrades = {
  multishot: 0,       // +1 bullet per level
  bigger: 0,          // +10% size & +10 life per level
  fasterFire: 0,      // multiplicative ×0.85 per level, min 60ms
  homingBullets: 0,   // +0.06 steering per level
  piercing: 0,        // +1 pierce per level
  addAmmo: 0,         // +1 loaded ammo when picked
  addMaxAmmo: 0       // +2 magSize per pick
};

/* missile types base speeds */
const BASE_TYPE_SPEED = { basic:2.4, burner:3.4, smart:2.6, cluster:2.2 };

/* starfield */
let starCanvas = null;
function makeStars(){
  starCanvas = document.createElement('canvas');
  starCanvas.width = canvas.width; starCanvas.height = canvas.height;
  const sctx = starCanvas.getContext('2d');
  sctx.fillStyle = '#030417';
  sctx.fillRect(0,0,starCanvas.width,starCanvas.height);
  for(let i=0;i<180;i++){
    sctx.fillStyle = `rgba(255,255,255,${Math.random()*0.6})`;
    sctx.fillRect(Math.random()*starCanvas.width, Math.random()*starCanvas.height, Math.random()*2+0.3, Math.random()*2+0.3);
  }
}
makeStars();

/* --- Utilities --- */
function rand(a,b){ return a + Math.random()*(b-a); }
function len(x,y){ return Math.hypot(x,y); }
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

/* -------------------------
   Spawning & Difficulty
   ------------------------- */
let spawnTimer = 0;
const BASE_SPAWN_INTERVAL = 0.6;

function pickMissileType(){
  const r = Math.random();
  if(r < 0.6) return 'basic';
  if(r < 0.8) return 'burner';
  if(r < 0.92) return 'smart';
  return 'cluster';
}

function spawnMissile(){
  if(missiles.length >= missileCap) return;
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x=-60; y=rand(0,canvas.height); }
  else if(side===1){ x=canvas.width+60; y=rand(0,canvas.height); }
  else if(side===2){ x=rand(0,canvas.width); y=-60; }
  else { x=rand(0,canvas.width); y=canvas.height+60; }
  const type = pickMissileType();
  const baseSpeed = BASE_TYPE_SPEED[type];
  const speed = baseSpeed + baseDifficultySpeedBonus;
  missiles.push({ x,y, vx:0, vy:0, type, speed, age:0 });
}

/* -------------------------
   Shooting / Bullets
   ------------------------- */
function startReload(){
  if(reloading) return;
  reloading = true;
  setTimeout(()=>{ bulletsInMag = magSize; reloading = false; updateUI(); }, reloadTime);
}

function computeFireRate(){
  const rate = Math.round(BASE_FIRE_RATE * Math.pow(0.85, upgrades.fasterFire));
  return Math.max(60, rate);
}

function shootNow(){
  const now = performance.now();
  fireRate = computeFireRate();
  if(now - lastShotTime < fireRate) return;
  if(reloading) return;
  if(bulletsInMag <= 0){ startReload(); return; }
  lastShotTime = now;

  // multishot: 1 + upgrades.multishot
  const shots = 1 + upgrades.multishot;
  // spread grows lightly with more shots
  const spread = shots > 1 ? Math.min(0.28, 0.08 + (shots-1)*0.06) : 0;

  // base bullet speed slightly increased by bigger (small feel change)
  const baseBulletSpeed = 12 + upgrades.bigger * 1.2;
  const baseLife = 90 + upgrades.bigger * 10;
  for(let i=0;i<shots;i++){
    const t = shots===1 ? 0.5 : (i/(shots-1 || 1));
    const a = rocket.angle + ( (t-0.5) * spread ) * (Math.random()*0.9 + 0.1);
    bullets.push({
      x: rocket.x + Math.cos(a)*22,
      y: rocket.y + Math.sin(a)*22,
      vx: Math.cos(a)*baseBulletSpeed,
      vy: Math.sin(a)*baseBulletSpeed,
      life: baseLife,
      pierce: upgrades.piercing,              // how many extra missiles it can pass through
      homing: upgrades.homingBullets > 0
    });
    // recoil per shot (smaller with multishot)
    const recoilStrength = 0.65 * (baseBulletSpeed / 12) * (shots === 1 ? 1 : 0.55);
    rocket.vx -= Math.cos(a) * recoilStrength;
    rocket.vy -= Math.sin(a) * recoilStrength;
  }

  bulletsInMag--;
  if(bulletsInMag <= 0) startReload();
  updateUI();
}

/* -------------------------
   Upgrades / Leveling
   ------------------------- */
const ALL_UPGRADES = [
  { id:'multishot', name:'Multi-shot', desc:'Add +1 bullet per upgrade' },
  { id:'bigger', name:'Bigger Bullets', desc:'+10% size & +10 range per upgrade' },
  { id:'fasterFire', name:'Faster Fire Rate', desc:'Each upgrade reduces delay by 15%' },
  { id:'homingBullets', name:'Homing Bullets', desc:'Bullets curve toward missiles (stronger each upgrade)' },
  { id:'piercing', name:'Piercing Shot', desc:'+1 pierce per upgrade' },
  { id:'addAmmo', name:'+Ammo', desc:'Add +1 loaded ammo (not above magazine size)' },
  { id:'addMaxAmmo', name:'Increase Mag Size', desc:'+2 magazine size per upgrade' }
];

function offerUpgrade(){
  pausedForUpgrade = true;
  overlay.classList.add('show');
  choicesEl.innerHTML = '';
  // pool and prefer lower-level upgrades (so unpicked options appear more)
  let pool = [...ALL_UPGRADES];
  pool.sort((a,b)=> ( (upgrades[a.id]||0) - (upgrades[b.id]||0) ));
  const opts = [];
  while(opts.length < 3 && pool.length){
    const idx = Math.floor(Math.random()*pool.length);
    opts.push(pool.splice(idx,1)[0]);
  }
  opts.forEach(o=>{
    const lvl = upgrades[o.id] || 0;
    const div = document.createElement('div');
    div.className = 'choice';
    div.innerHTML = `<h3>${o.name} ${lvl>0?`(Lv ${lvl})` : ''}</h3><div class="small">${o.desc}</div>`;
    div.onclick = ()=>{
      applyUpgrade(o.id);
      overlay.classList.remove('show');
      pausedForUpgrade = false;
    };
    choicesEl.appendChild(div);
  });
}

function applyUpgrade(id){
  // increase the counter
  upgrades[id] = (upgrades[id] || 0) + 1;

  // handle immediate or computed effects
  if(id === 'addMaxAmmo'){
    // increase magazine size immediately by +2 (cap to some reasonable max)
    magSize = Math.min(40, magSize + 2);
    // if we just increased magSize, give a small ammo boost
    bulletsInMag = Math.min(magSize, bulletsInMag + 1);
  }

  if(id === 'addAmmo'){
    // add 1 loaded ammo right away, but not beyond magSize
    bulletsInMag = Math.min(magSize, bulletsInMag + 1);
  }

  if(id === 'fasterFire'){
    // recompute fireRate using computeFireRate()
    fireRate = computeFireRate();
  }

  // update UI
  updateUI();
}

/* -------------------------
   Collisions & Game Logic
   ------------------------- */
function bulletHitsMissile(b,m){
  // missile base hit radius
  const baseHit = (m.type==='cluster'?18:16);
  // bigger increases bullet effective hit by 10% size per level — simpler: add +2 px per bigger level
  const extra = upgrades.bigger * 2;
  const hitRadius = baseHit + extra;
  return Math.hypot(b.x - m.x, b.y - m.y) < hitRadius;
}

function updateDifficultyAndLevel(){
  // every 5 kills increases missile cap and difficulty speed
  if(killCount > 0 && killCount % 5 === 0){
    missileCap = Math.min(missileCap + 1, missileCapMax);
    baseDifficultySpeedBonus += 0.25;
  }
  if(killsSinceLevel >= 5){
    killsSinceLevel = 0;
    level++;
    offerUpgrade();
  }
}

/* -------------------------
   Update Loop
   ------------------------- */
let last = performance.now();
function frame(now){
  const dt = Math.min(0.04, (now - last) / 1000);
  last = now;
  if(!pausedForUpgrade) update(dt);
  render();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

function update(dt){
  if(gameOver) return;

  // rotation
  if(keys['ArrowLeft']) rocket.angle -= rocket.rotationSpeed;
  if(keys['ArrowRight']) rocket.angle += rocket.rotationSpeed;

  // thrust ramping
  if(keys['ArrowUp']){
    const target = rocket.thrustBase;
    const step = target * (dt / rocket.thrustRampTime);
    rocket.thrustApplied = clamp(rocket.thrustApplied + step, 0, target);
    rocket.vx += Math.cos(rocket.angle) * rocket.thrustApplied;
    rocket.vy += Math.sin(rocket.angle) * rocket.thrustApplied;
  } else {
    const step = rocket.thrustBase * (dt / rocket.thrustRampTime);
    rocket.thrustApplied = clamp(rocket.thrustApplied - step, 0, rocket.thrustBase);
  }

  // braking
  if(keys['ArrowDown']) { rocket.vx *= 0.96; rocket.vy *= 0.96; }

  // shooting (support hold-fire)
  if(keys['Space'] && !pausedForUpgrade) shootNow();

  // boost charge
  if((keys['ShiftLeft'] || keys['ShiftRight']) && boostReady){
    boostCharge += dt * (1000 / BOOST_CHARGE_TIME);
    if(boostCharge > 1) boostCharge = 1;
    boosting = true;
  } else if(boosting){
    boosting = false;
    if(boostCharge > 0.12 && boostReady){
      const power = 6 + boostCharge * 14;
      rocket.vx += Math.cos(rocket.angle) * power;
      rocket.vy += Math.sin(rocket.angle) * power;
      boostReady = false;
      lastBoostAt = performance.now();
      setTimeout(()=>{ boostReady = true; updateUI(); }, BOOST_COOLDOWN);
    }
    boostCharge = 0;
  }

  // drag and cap speed
  rocket.vx *= rocket.drag; rocket.vy *= rocket.drag;
  let speed = Math.hypot(rocket.vx, rocket.vy);
  if(speed > PLAYER_MAX_SPEED){
    rocket.vx = (rocket.vx / speed) * PLAYER_MAX_SPEED;
    rocket.vy = (rocket.vy / speed) * PLAYER_MAX_SPEED;
  }

  rocket.x += rocket.vx; rocket.y += rocket.vy;

  // wrap
  if(rocket.x < 0) rocket.x = canvas.width;
  if(rocket.x > canvas.width) rocket.x = 0;
  if(rocket.y < 0) rocket.y = canvas.height;
  if(rocket.y > canvas.height) rocket.y = 0;

  // bullets update
  for(let b of bullets){
    if(b.homing && missiles.length){
      let nearest = null, nd = 1e9;
      for(let m of missiles){
        const d = len(m.x - b.x, m.y - b.y);
        if(d < nd){ nd = d; nearest = m; }
      }
      if(nearest){
        const dx = nearest.x - b.x, dy = nearest.y - b.y;
        const d = Math.hypot(dx,dy) || 1;
        const homingPower = 0.12 + (upgrades.homingBullets * 0.06);
        b.vx += (dx/d) * homingPower;
        b.vy += (dy/d) * homingPower;
        const mag = Math.hypot(b.vx, b.vy) || 1;
        const sp = 12 + upgrades.bigger * 1.2;
        b.vx = (b.vx / mag) * sp;
        b.vy = (b.vy / mag) * sp;
      }
    }
    b.x += b.vx; b.y += b.vy; b.life--;
  }

  // remove bullets offscreen or expired
  bullets = bullets.filter(b => b.life > 0 && b.x >= -40 && b.x <= canvas.width+40 && b.y >= -40 && b.y <= canvas.height+40);

  // spawn missiles
  spawnTimer += dt;
  const spawnInterval = Math.max(0.25, BASE_SPAWN_INTERVAL - baseDifficultySpeedBonus * 0.03);
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    spawnMissile();
  }

  // missile AI
  for(let m of missiles){
    m.age += dt;
    const dx = rocket.x - m.x, dy = rocket.y - m.y;
    const dist = Math.hypot(dx,dy) || 1;

    if(m.type === 'basic'){
      m.vx += (dx/dist) * 0.12;
      m.vy += (dy/dist) * 0.12;
      const mag = Math.hypot(m.vx,m.vy) || 1;
      m.vx = (m.vx / mag) * m.speed;
      m.vy = (m.vy / mag) * m.speed;
    } else if(m.type === 'burner'){
      if(m.age < 0.4){
        m.vx = (dx/dist) * m.speed * 0.6;
        m.vy = (dy/dist) * m.speed * 0.6;
      } else {
        m.vx += (dx/dist) * 0.06; m.vy += (dy/dist) * 0.06;
        const mag = Math.hypot(m.vx,m.vy) || 1;
        m.vx = (m.vx/mag) * m.speed; m.vy = (m.vy/mag) * m.speed;
      }
    } else if(m.type === 'smart'){
      const predictT = Math.min(60, dist / (m.speed + 0.5)) * 0.12;
      const targetX = rocket.x + rocket.vx * (predictT * 40);
      const targetY = rocket.y + rocket.vy * (predictT * 40);
      const dx2 = targetX - m.x, dy2 = targetY - m.y;
      const d2 = Math.hypot(dx2,dy2) || 1;
      m.vx += (dx2/d2) * 0.16; m.vy += (dy2/d2) * 0.16;
      const mag = Math.hypot(m.vx,m.vy) || 1;
      m.vx = (m.vx/mag) * m.speed; m.vy = (m.vy/mag) * m.speed;
    } else if(m.type === 'cluster'){
      m.vx += (dx/dist) * 0.10; m.vy += (dy/dist) * 0.10;
      const mag = Math.hypot(m.vx,m.vy) || 1;
      m.vx = (m.vx/mag) * m.speed; m.vy = (m.vy/mag) * m.speed;
    }

    m.x += m.vx; m.y += m.vy;

    // wrap missiles
    if(m.x < 0) m.x = canvas.width;
    if(m.x > canvas.width) m.x = 0;
    if(m.y < 0) m.y = canvas.height;
    if(m.y > canvas.height) m.y = 0;
  }

  // bullet hits missile
  for(let i = missiles.length - 1; i >= 0; i--){
    const m = missiles[i];
    for(let j = bullets.length - 1; j >= 0; j--){
      const b = bullets[j];
      if(bulletHitsMissile(b,m)){
        // handle piercing: if bullet has pierce (count), decrement and reduce life; otherwise kill bullet
        if(b.pierce && b.pierce > 0){
          b.pierce--;
          b.life -= 20;
        } else {
          b.life = -1;
        }

        // cluster spawn babies
        if(m.type === 'cluster'){
          for(let k=0;k<3;k++){
            missiles.push({
              x: m.x + rand(-8,8),
              y: m.y + rand(-8,8),
              vx: rand(-1,1),
              vy: rand(-1,1),
              type: 'basic',
              speed: BASE_TYPE_SPEED.basic + baseDifficultySpeedBonus * 0.8,
              age:0
            });
          }
        }

        missiles.splice(i,1);
        killCount++; killsSinceLevel++;
        updateDifficultyAndLevel();
        updateUI();
        break;
      }
    }
  }

  // bullets can hit player (self-hit) - scale radius with bigger
  const selfHitRadius = 14 * (1 + 0.10 * upgrades.bigger);
  for(let b of bullets){
    if(len(b.x - rocket.x, b.y - rocket.y) < selfHitRadius){
      onDeath();
      return;
    }
  }

  // missiles hit player
  for(let m of missiles){
    if(len(m.x - rocket.x, m.y - rocket.y) < 22){
      onDeath();
      return;
    }
  }

  // UI tick
  updateUI();
}

/* -------------------------
   Death / Restart
   ------------------------- */
function onDeath(){
  gameOver = true;
  gameOverEl.style.display = 'block';
  pausedForUpgrade = false;
  overlay.classList.remove('show');
}

/* -------------------------
   Rendering
   ------------------------- */
function render(){
  // background
  ctx.drawImage(starCanvas, 0, 0);

  // missiles
  for(let m of missiles){
    if(m.type === 'burner'){
      ctx.fillStyle = 'rgba(255,120,50,0.95)';
      ctx.beginPath(); ctx.ellipse(m.x - m.vx*2, m.y - m.vy*2, 8,4,0,0,Math.PI*2); ctx.fill();
    } else if(m.type === 'smart'){
      ctx.fillStyle = 'rgba(220,60,160,0.95)';
    } else if(m.type === 'cluster'){
      ctx.fillStyle = 'rgba(200,90,40,0.95)';
    } else {
      ctx.fillStyle = 'rgba(220,40,40,0.95)';
    }
    ctx.beginPath(); ctx.arc(m.x, m.y, m.type==='cluster'?13:10, 0, Math.PI*2); ctx.fill();
  }

  // bullets
  for(let b of bullets){
    const baseRadius = 3;
    const radius = baseRadius * (1 + 0.10 * upgrades.bigger);
    ctx.fillStyle = 'yellow';
    ctx.beginPath(); ctx.arc(b.x, b.y, radius, 0, Math.PI*2); ctx.fill();
  }

  // boost effect / glow
  if(boostCharge > 0){
    const g = 0.12 + 0.6 * boostCharge;
    ctx.save();
    ctx.translate(rocket.x, rocket.y);
    ctx.rotate(rocket.angle);
    ctx.fillStyle = `rgba(180,230,255,${g})`;
    ctx.beginPath(); ctx.ellipse(0,0, 36 + boostCharge*28, 18 + boostCharge*14, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // rocket
  ctx.save();
  ctx.translate(rocket.x, rocket.y);
  ctx.rotate(rocket.angle);
  ctx.fillStyle = '#AEEAFF';
  ctx.fillRect(-20, -10, 40, 20);
  if(keys['ArrowUp']){
    const thr = rocket.thrustApplied / rocket.thrustBase;
    ctx.fillStyle = 'orange';
    ctx.beginPath();
    ctx.moveTo(-20, -8);
    ctx.lineTo(-34 - Math.random()*6 - thr*10, 0);
    ctx.lineTo(-20, 8);
    ctx.fill();
  }
  ctx.restore();

  // UI overlay for death
  if(gameOver){
    ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  }
}

/* -------------------------
   Input: space fires on keydown, r restarts
   ------------------------- */
window.addEventListener('keydown', e=>{
  if(e.code === 'Space'){ e.preventDefault(); if(!pausedForUpgrade) shootNow(); }
  if(e.code === 'KeyR'){
    if(gameOver) restartGame();
    else {
      restartGame();
    }
  }
});

/* -------------------------
   UI
   ------------------------- */
function updateUI(){
  ammoUi.textContent = `Ammo: ${bulletsInMag}/${magSize} ${reloading ? '(reloading)' : ''}`;
  killsUi.textContent = `Kills: ${killCount} | Level: ${level}`;
  boostUi.textContent = boostReady ? 'Boost: READY' : `Boost: ${Math.max(0, Math.ceil((BOOST_COOLDOWN - (performance.now()-lastBoostAt))/1000))}s`;
  metaUi.textContent = `Max Missiles: ${missileCap} (cap ${missileCapMax}) | Missile Speed Bonus: ${baseDifficultySpeedBonus.toFixed(2)}`;
  // upgrades summary
  const parts = [];
  for(const k in upgrades){
    if(upgrades[k]) parts.push(`${k}: ${upgrades[k]}`);
  }
  upgradesUi.textContent = `Upgrades: ${parts.length? parts.join(' | ') : '—'}`;
}

/* -------------------------
   Restart
   ------------------------- */
function restartGame(){
  // reset core state
  rocket.x = canvas.width/2; rocket.y = canvas.height/2; rocket.vx = 0; rocket.vy = 0; rocket.angle = 0;
  bullets = []; missiles = [];
  // reset magazine to base magSize (we keep magSize default unless addMaxAmmo had been picked — requirement said upgrades reset on death)
  magSize = 10;
  bulletsInMag = magSize; reloading = false;
  killCount = 0; killsSinceLevel = 0; level = 1;
  missileCap = startingMissileCap; baseDifficultySpeedBonus = 0;
  // RESET UPGRADES to zero
  upgrades = { multishot:0, bigger:0, fasterFire:0, homingBullets:0, piercing:0, addAmmo:0, addMaxAmmo:0 };
  // reset related vars
  fireRate = BASE_FIRE_RATE; maxAmmo = BASE_MAX_AMMO;
  gameOver = false; gameOverEl.style.display = 'none';
  pausedForUpgrade = false; overlay.classList.remove('show');
  boostReady = true; boostCharge = 0;
  updateUI();
}

/* -------------------------
   Kickoff
   ------------------------- */
updateUI();
requestAnimationFrame(frame);

/* -------------------------
   End of script
   ------------------------- */
</script>
</body>
</html>
